# Тестовое задание в компанию Swoyo

### Задание 1. API
C помощью python requests забронировать комнату, изменить дату заезда, распечатать в консоль свое бронирование (используя информацию с сайта), удалить бронь и убедиться что бронь удалена на сайте. https://restful-booker.herokuapp.com/apidoc/index.html

В соответствии с заданием написан класс Booking, который имеет методы, реализующие всё это. Соответствие метода конкретному пункту задания прописано в комментариях кода, но я также приведу соответсвия сдесь:
1) Забронировать комнату - метод create()
2) Изменить дату бронирования - метод update_date(new_chekin, new_chekout)
3) Распечатать в консоль своё бронирование - метод get()
4) Удалить бронь - метод delete()
5) Убедиться что бронь удалена - Можно убедиться в этом по коду ответа 201 после вызова delete или повторно вызвать метод get, уже после удаления бронирования. Для второго случая я не изменяю id бронирования.

Также в классе присутвтвует метод make_json(), который возвращает строку - json, корректную для отправки на сайт. В этом методе изпользуется библиотека json.

Помимо этого класса в папке первог задания есть файл main.py в нём реализована функция для удобной работы с классом и его тестирования.

### Задание 2. Клиент-сервер
Написать на питоне клиент-сервер json валидатор. т.е. клиент отправляет серверу любую строку, а сервер в качестве ответа выдает True - если строка формата json, или False если нет.
*Я не очень понял, какого типа переменные стоит возвращать (bool или string), по этому возвращаю байтовые строки b'True' или b'False' соответственно.

Для проверки строки на то, является ли она json или нет используется простая функция и библиотека json
```python
def is_json(my_json):
    try:
        # Проверяю на возможность перевести из json
        json.loads(my_json)
    except ValueError as e:
        return b'False'
    try:
        # Проверяю, что это не число (например '123')
        int(my_json)
    except ValueError as e:
        return b'True'
    return b'False'
```

А само устройство клиента и сервера довольно стандартно, сокеты открываются через with, отправляют сообщения через метод sendall() принимают через метод recv().
Сервер запускаю просто через pycharm как обычный python файл, а client.py запускаю в том же пайчарме, но через терминал.

### Исправление заданий после фидбека.

Мне пришли комментарии к тестовому заданию
QA - "1 задание. Задача стояла следующая: создать бронь и поработать с ней, задание выполнено совершенно в другом ключе. Кандидат подготовил интерактивную программу по работе с бронированиями для пользователя, где что-то сделать с бронью можно только с непосредственным участием пользователя. 
Нет проверок на response code. Booking класс  может работать только с одной бронью, а что если пользователя захочет сделать несколько бронирований? Внутри кода много остальных мелких недоработок и несоответствий README.md.
2 задание. is_json - не совсем рациональна. "

1) Как я понял, интерактивная программа, которую я сделал для удобства проверяющего - совсем лишнее. Значит этот код нужно удалить и в файле работы программы просто взять и ручками отправить запросы в нужном порядке (а не автоматически после работы с прогой через input).
2) Проверки на rensponse code - Тут я действительно не прав, что так не сделал, просто проверял всё глазами, принтуя ensponse code и совсем не подумал о проверке внутри программы (мб пользователю не будут выводить rensponse code или он просто не будет знать, что это за коды).
3) Что делать, если нужно создать ещё одну бронь? - создать ещё один экземпляр класса Booking. Но я думаю что это критика относиться именно к отсутствию такой возможности в "интерактивной программе".
4) Недоработки внутри кода и мелкие не соответствия - как я понял, людям не хочется тратить время на то, чтобы точно их указать и они в этом правы.

Ну и вишенка на торте из фидбека <mark> 2 задание. is_json - не совсем рациональна.</mark>
Я не уверен, что имеется ввиду под этим, но мне кажется использовать библиотеку json для проверки json это самое рациональное, что можно сделать.
У тебя не уходит дополнительного времени на написание своего json валидатора и ты пишешь только сервер. 
С другой стороны, это тестовое задание, мб надо было показать, что я сам смогу написать такую функцию.
Ну или то, что я умею пользоваться встроенными библиотеками большой плюс. Не уверен.

Во втором задании я немного переделал эту функцию, теперь она выглядит так:
```python
def is_json(my_json):
    try:
        # Проверяю на возможность перевести из json
        print(my_json)
        my_json = json.loads(my_json.decode("utf-8"))
        if type(my_json) == 'dict':
            return b'False'
        return b'True'
    except ValueError as e:
        return b'False'
```
Она стала короче и теперь я не ловлю 2 ошибку (при попытке переделать в int), а просто проверяю, что мне прислали словарь
P.S. Если мне пришлют словарь, который не является json, то это вызовет ValueError после json.loads()

